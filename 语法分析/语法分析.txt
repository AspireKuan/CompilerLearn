=======2019.10.15.17:26(Tuesday)=======

在这里FIRST和FOLLOW算法中，有一个大前提就是非终结符仅仅只能是一个字符，终结符可以是多个字符（例如id）

****设计问题
1.我将First_set中src设计为char*，但是data设计为DyString，是有一定的原因的。因为我认为，对于src来说，
一般来说就是一个或者两个字符，但是data是很多字符的集合，是需要将其准确记录其长度的

2.在将一个FIRST()集合复制给另外一个FIRST()集合的时候，我一开始打算采用从后往前复制，但是发现这样子
在strncpy()函数调用的时候会出错，而且也不好使用。最后只能从前往后复制观察了。
就是在这里，暂时还是不知道怎么优化自己的速度

3.本来在FIRST集合中我也是采用的flag字段来更新，但是后来采用了一个copy_first_follow()函数，所以，虽然
暂时FOLLOW集合没有采用flag来标识，但是为了统一，还是将copy_first_follow()函数设置一个Fisrst_set/Folllow_set
字段中的flag标记参数

4.find_vt()这个函数想法：
我一开始是这样定义的：int find_vt(DyString *data, Node **arr);但是对于表达式来说，它可能仅仅就
只需要检测部分符号，所以传入一个DyString不太好处理

=======2019.10.18.19:29(Friday)=======
FIRST集合基本上没有问题了。就是自己的写的get_complete_vt()函数有点问题。一直有一个问题，具体见demo.cpp
文件。接下来就是FOLLOW集合的构造了。

****设计思路：
1.首先FOLLOW集合是针对于非终结符来说的，所以在扫描表达式的时候就仅仅只需要考虑非终结符

2.我觉得一个更好思路就是：对于每一个表达式我采用从后往前扫描的方式，因为这样是能够更快的决定是否要采用
这个规则：A->aB,FOLLOW(B)=FOLLOW(B) U FOLLOW(A)

3.设置当前非终结符为cur，cur后面的文法符号为next；对于表达式最右的非终结符而言，它的next就是产生式左部
的符号

4.对于原符号'|'，是要特殊处理的。例如：next值要发生变化，就是产生式左部的符号了

5.在get_follow()函数中，为什么要在changing_count >1 的时候才执行这个操作。
if (changing_count > 1)
{
	Vfollow[curindex].flag = 0;
}
因为'#'在初始化的时候就赋值给FOLLOE(E)了。如果，第一个产生式是这样的：E->A;A->E;
那么你在从后往前扫描的时候，因为你前面将Vfollow[curindex].flag
=0;那么因为第一个产生式没有将E的flag变为1，所以A就没有得到E的'#'，但是实际上现在应该将'#'赋值给FOLLOW(A)
还有，因为在初始化的时候，就将其全部flag变成了0,所以，在change_count==1的时候，不去执行
Vfollow[curindex].flag = 0;也是没有什么问题的。
后来发现没有必要这样做。因为FOLLOW集合首先你要依赖于FIRST和，所以我一开始在初始化FOLLOW的时候，就将其
FOLLOW.flag设置为1，之后就是change_count>1的时候，每次遍历才需要先设置为0

6.在get_follow()函数中，也有检查重复元素，但是我觉得外层循环从前往后扫描，内层循环从后往前扫描并不能达到
加快检查的速度，反而可能有些元素无法复制成功。

7.
a.在get_follow()函数中，有一个测试该文法符号可以不可以成为该产生式的最后一个非终结符符号的资格。我采用
两个变量来实现的。last_character_is_end和is_null来实现。last_character_is_end代表上一个文法符号（终
结符和非终结符）是否可以成为该表达式的最后一个非终结符。如果可以的话，并且is_null（又代表上一个文法符号
的first时候包含空串）==1（表达含有空串），那么curchar也就可以成为该表达式的最后一个非终结符。我一开始
还想的一个方法就是在Follow_set结构体中包含这样一个结构，但是一想，那样就比较浪费内存了。

b.这个方法在for循环的一开始就在寻找一个非终结符，如果，找找到的非终结符不是最后一个字符，说明，后面是
一个终结符，所以last_character_is_end=0;如果是一个非终结符，那么在for循环开始就是1了。

c.在使用这个方法的时候，特别要注意'|'的符号的处理，如果curchar后面是一个'|'，那么就不用看后面文法符号
是不是包含空串了。

d.在每扫描一个产生式的时候，都会要重置一下这两个参数，因为对于不同的产生式而言，这两个参数是没有意义的
所以，我就直接将其定义在了这个for循环的开始。last_character_is_end初始化为1，is_null初始化为0

8.在得到一个非终结符的函数get_variable(char *src,int *sindex)中,虽然参数使用的是char *.但是实
际上还是仅仅采用的是一个char ch[2].不然的话，在find_vt()函数中会出现问题。


9.copy_follow_first()函数设计初衷：
a.每次得到两个集合（是FiRST和FOLLOW的组合），需要复制同时判断是否含有空。

b.可能是FOLLOW相互复制，也有可能是FIRST复制给FOLLOW

c.在执行的函数的过程中就执行了非重复，非空串复制也有可能没有复制（因为都是一些重复的元素），所以
还要使用flag来判断。因为在最外层的while()中就是使用flag来判断FOLLOW集合是不是稳定了。所以，这里
传入一个flag，来做这个事情。

10.对于求FOLLOW集合的时候，我没有采用和FIRST集合时一样的方法，采用一个在Follow_set中的flag字段来判断
是不是新增加了元素。原因是因为Follow集合的产生，不仅仅要有FIRST集合的值，还有FOLLOW集合的值。就目前
来看，没有找到一个好的方法来判断。目前采用的就是都是直接复制，但是会判断是否有重符元素。

=======2019.10.20.09:49(Sunday)=======

11.在做到LL(1)分析表的时候，发现要对每一个产生式的右部求FIRST集合，但是我设计的时候是对于每一个产生式
左部求FIRST集合。我的求出来的就是每一个整个的表达式，所以我现在得将其拆分出来处理。

12.因为现在还需要直到某个文法符号的位置（因为要确定'|'的位置），所以要重新处理find_str()函数的返回值。
因为我一开始设计的就是如果存在返回1，不存在返回0。但是其实完全可以设计的更加宽泛一点，存在就返回所查
字符的下标，不存在就返回-1。至于使用者去不去使用你得返回值，那是它的事情，至少这样写之后代码健壮性更
强大了。

13.
a.在设计get_first_candidate()函数的时候，就在设计返回值的时候有些斟酌。因为针对于一个产生式而言，尤其
是FIRST集合而言，其实需不要需要扫面整个产生式在从左至右的扫描过程中就可以判断出来了。因为在一个产生式
中（这里不会有'|'了，所以这里说的一个产生式就是一个产生式），每次都是得到这个产生式的第一个文法符号，
只要这个文法符号要么是终结符，要么是非终结符。是终结符的话，产生式之后也就都不用考虑了，如果是非终结符
的话，如果不包含空串，那么之后的也不用考虑了。除非是非终结符，且包含空串，就要继续扫描这个产生式。

b.它的返回值是用来测试这整个产生式是否可以隐式推出空串。例如：A->BC;如果B和C的FIRST都可以推出空串，那么
A也是可以推出空串的。至于get_first_candidate()函数，里面判断是否为空，是针对于是否要继续扫面这个产生式。

**c.此时要找一下这个终结符能否推出空串，因为虽然此时不用复制数据，但是还是要看看它能不能推出空串。因为
这个关系着现在还要不要继续扫描下去的问题。在get_first_candidate()函数内部，is_null成立就要继续扫描，在
get_first2()函数中，is_null成立是要将 空字符串添加到VTfirst[curindex].data中。



=======2019.10.20.15:58(Sunday)=======
FIRST集合和FOLLOW集合的优化已经完成。现在来判断是不是一个LL(1)文法。
14.在检查是否有交集的时候，我考虑过使用“并查集”来做。觉得这样子应该可以加快查找效率。这样子对于一个
有一个右部的产生式是十分友好的。最后就演变成了一个采用标记数组来判断是否有重复的方法，而不是采用简单
的双重for循环来实现的。

15.显然，应该要先看看具有相同左部的右部候选式是否能够推出空串，如果有一个能推导出空串，那么就只有它
可以推导出空串，其他的都不能推导出空串。并且，在其他候选式和它进行比较的时候，采用的是FOLLOW和FIRST集合
的比较，两个非空的候选式的比较式FIRST集合的比较

16.最后我采用的判断方式是我们教材（陈火旺老师）上的一种方式：因为在哈工大教材和龙书上面关于LL(1)文法的
判断，考虑的情况比较细致，那么编程实现的过程中，就会导致需要判断的条件比较多。但是陈火旺老师书本上给出
的判断方式就是比较简单，编程实现比较容易。

17.这里又引出了一个设计接口的问题。因为我在设计 int get_first_candidate
(int curindex, int *flag, const char *str);函数的时候，是直接将得到的结果通过curindex直接送
到VTfirst数组中了。那么，这个就导致了我现在在要去判断FIRST(ai)的时候，就无法直接获取到这个结果。果然，
这个大局观太重要了。我现在估计又只能重构我的代码了。我采用的就是现在将VTfirst当作形参传入进去，而不是
利用全局变量的特性（真的，少用全局变量）。因为那样子我的代码就不具备扩展性了。


18.这里我突然发现我设计的find_str()的一个弊端了。因为find_str()的本质是基于你找的都是一个终结符或者非
终结符。但是'|'并不是一个终结符，或者非终结符。所以就会导致你find_str()在调用get_complete_vt()的时候
将这个'|'符号自动略过，所以你得程序就无法判断。为了程序改动较少一点，只有新写出一个函数来判断了。


19.现在程序一个很大的问题就是：我现在需要一个能够根据char *str来求FIRST集合的函数
（我自己写的一个是get_first_candidate()）,但是问题在于，我设计的是采用是非递归的方式求出来的。按照现在
看来，这个函数应该要是一个递归函数才可以。但是现在的问题就是得重新写一个出来。
如果不想要自己写出来的话，就必须自己通过已知的FIRST集合，来得到这个char *str集合。

20.最后自己“打了个补丁”，就解决上面的问题了




=======2019.10.22.20:44(Tuesday)=======
LL(1)文法判断完成
21.在设计LL(1)预测分析表的时候，就想到一个问题。到底是应该形成一个DyString[]，还是就是一个char *
数组，这个觉得采用char *比较合适。因为在预测分析的过程中，每一个元素都是可以直接一次性完成的。之前
之所以使用DyString*,就是因为需要动态扩展，因为有些结果并不是一次性就可以得出来的。

22.get_string_first()我为什么没有设计为一个直接就是通过得到first(src)，然后复制给char *dst
就可以了，这样子岂不是更加方便。但是，由于之前的copy_follow_first()函数设计的就是DyString*
的参数，所以一改动的话就是所有的就都要改动。
****这里给我的经验就是：如果可以传入char*参数的，可以就直接传入char*,除非你的函数里里面需要动态扩展。
不然的话，其实对于一个一个DyString*和char*而言，没有什么太大的区别。因为char*也是可以判断出结尾的数据。
所以我在后面的函数设计接口的过程中，都是直接采用的const char*来做的。

23.在这个find_analysis_index()函数中，我采用的get_complete_ct()函数并没有获取其返回值，来改变下一次的
起点位置。原因就是在这里，你得每一个其实都是一个元素，你现在使用这个函数的目的在于获取一个，因为每一个
终结符或者非终结符的长度是不一样的。但是之前的为什么要使用get_complete_vt()函数的返回值呢？是因为之前的
是一个FIRST集合，里面包含了几个非终结符。但是我这里就是每一个里面就一个终结符或者非终结符！



=======2019.10.23.21:07(Wednesday)=======
预测分析表完成！
在这个过程中，真的体会到了自己没有大局观，自己设计的接口真的就是很局限。仅仅只能考虑到现在的一些问题，
无法做到从大局来考虑。



=======2019.10.24.14:17(Thursday)=======
24.
a.在设计栈的过程中，一开始想到的就是采用字符栈，但是一想，里面可能会有id这样的非终结符，所以最好的方式
还是采用一个DyString 的栈。
b.但是发现这个必须要DyString *str必须有一个next指针将其串起来。但是我在当初设计这个DyString *的时候，又
没有设计这个指针。而且，我想到了之前我就一直觉得vector<> vc中的pop_back()函数，其实我觉得就是这个功能。
每次就是pop_back()出来的就是最后面的的那个元素（也就是最近）加上去的那个元素。所以，我打算自己设计一个
这样的栈来实现这个功能。就是这么设计了，但是就是不知道之后的效果怎么样。


25.发现自己那样设计没有什么问题，而且可以很好的运行出来。这个我觉得也是一种比较好栈的实现。其实计算机
都是一个人逻辑的体现，你只用那么去向想，你规定只要那样去做才是正确的就可以了。这样子，你得操作就是你
所想要的结果了。












****代码问题
1.在get_first()中，你一开始写成了strncpy(tmp, (const char*)Pstring[i].data[j], n);
但是你要清楚就是：Pstring[i].data[j]是一个char，而不是一个char
*。所以你上面的strncpy()函数就会报错

2.在find_vt()中：
a.你尝试将‘@’和char*str来比较的时候，因为你在上面使用了‘@’的宏定义，所以
if (!strcmp(str, (const char*)EMPTYSTRING))也是会报错的。因为宏展开的时候仅仅是字符替代而已，
所以就是if(!strcmp(str,(constchar*)‘@’))这个也是错误的。我觉得就是因为‘@’是一个常量吧，、
但是这样子的话，前面加上一个取地址就没有问题了。但是还是有问题。所以，最后就使用一个变量ch来代替了。
b.在使用char ch='@'去比较的时候，不要仅仅使用一个char ch；因为strcmpy()函数是要根据'\0'来正确使用的
所以你要构建一个数组：char ch[2]={'@','\0'}来调用strcmp()函数

3.要注意自己的定义的数据结构；对于FIRST集合来说里面是一个DyString,但是对于Pstring之类的来说，是一个
char *。因为你将他们都写成了data，尤其在strncpy()中比较容易出错。

4.
**a.在代码中，我一直出现一个 Run-Time Check Failure #2 - Stack around the variable 'ch1' was corrupte
的问题。我上网查找问题之后，网友说可能是内存访问错误，也就是可能使用了负数当作下标去访问内存。我想
这个编译器应该会报别的错误啊！怎么可能会是这个错误。但是我也就死马当做活马医，发现果然不是这个问题。
但是，最后上网看到一篇文章，说一般这样问题就是malloc()等内存操作函数的问题。然后我刚刚细细检查，发现
就是在定义了char ch1[MAXCHARNUM];但是在get_complete_vt()函数中却是这样memset()的。
memset(dst, 0,	MAXVTPNUM);也就是说，我分配了MAXCHARNUM（宏定义为16）个内存，但是却初始化
MAXVTPNUM（宏定义为32）个内存。所以在函数结束的时候，就会出现这样的问题。这里说到是ch1错误，你就在
ch1的周围好好好检查就好了。

**b.这个经验告诉我，经量在传参之前就初始化，而不是在函数里面进行初始化。因为以后可能这个函数是你写的，
但是另外一个函数不是你写的，你无法要求别人去初始化。所以，你自己在函数调用之前就一定要初始化。

5.想find_first_index()这样的函数，参数是一个char*str。如果你想要传入的是一个charch；然后你尝试
使用&ch当作实参传入进去，这样也是不可以的。因为你得函数实现肯定是根据'\0'来做判断标记的。
你仅仅传入&ch，是没有'\0'标记的。

6.在使用memset()函数时候，尤其是你要想清空一个结构体数据信息的时候，你一开始就将其所有的数据都清空为0了。
就是说，如果一个结构体里面有一个char *str;分配了空间，但是你直接使用memset()就会导致出现 str=0;的情况。
