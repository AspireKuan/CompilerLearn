=======2019.10.15.17:26(Tuesday)=======

在这里FIRST和FOLLOW算法中，有一个大前提就是非终结符仅仅只能是一个字符，终结符可以是多个字符（例如id）

****设计问题
1.我将First_set中src设计为char*，但是data设计为DyString，是有一定的原因的。因为我认为，对于src来说，
一般来说就是一个或者两个字符，但是data是很多字符的集合，是需要将其准确记录其长度的

2.在将一个FIRST()集合复制给另外一个FIRST()集合的时候，我一开始打算采用从后往前复制，但是发现这样子
在strncpy()函数调用的时候会出错，而且也不好使用。最后只能从前往后复制观察了。
就是在这里，暂时还是不知道怎么优化自己的速度

3.本来在FIRST集合中我也是采用的flag字段来更新，但是后来采用了一个copy_first_follow()函数，所以，虽然
暂时FOLLOW集合没有采用flag来标识，但是为了统一，还是将copy_first_follow()函数设置一个Fisrst_set/Folllow_set
字段中的flag标记参数

=======2019.10.18.19:29(Friday)=======
FIRST集合基本上没有问题了。就是自己的写的get_complete_vt()函数有点问题。一直有一个问题，具体见demo.cpp
文件。接下来就是FOLLOW集合的构造了。

****设计思路：
1.首先FOLLOW集合是针对于非终结符来说的，所以在扫描表达式的时候就仅仅只需要考虑非终结符

2.我觉得一个更好思路就是：对于每一个表达式我采用从后往前扫描的方式，因为这样是能够更快的决定是否要采用
这个规则：A->aB,FOLLOW(B)=FOLLOW(B) U FOLLOW(A)

3.设置当前非终结符为cur，cur后面的文法符号为next；对于表达式最右的非终结符而言，它的next就是产生式左部
的符号

4.对于原符号'|'，是要特殊处理的。例如：next值要发生变化，就是产生式左部的符号了

5.在get_follow()函数中，为什么要在changing_count >1 的时候才执行这个操作。
if (changing_count > 1)
{
	Vfollow[curindex].flag = 0;
}
因为'#'在初始化的时候就赋值给FOLLOE(E)了。如果，第一个产生式是这样的：E->A;A->E;
那么你在从后往前扫描的时候，因为你前面将Vfollow[curindex].flag
=0;那么因为第一个产生式没有将E的flag变为1，所以A就没有得到E的'#'，但是实际上现在应该将'#'赋值给FOLLOW(A)
还有，因为在初始化的时候，就将其全部flag变成了0,所以，在change_count==1的时候，不去执行
Vfollow[curindex].flag = 0;也是没有什么问题的。
后来发现没有必要这样做。因为FOLLOW集合首先你要依赖于FIRST和，所以我一开始在初始化FOLLOW的时候，就将其
FOLLOW.flag设置为1，之后就是change_count>1的时候，每次遍历才需要先设置为0

6.在get_follow()函数中，也有检查重复元素，但是我觉得外层循环从前往后扫描，内层循环从后往前扫描并不能达到
加快检查的速度，反而可能有些元素无法复制成功。

7.
a.在get_follow()函数中，有一个测试该文法符号可以不可以成为该产生式的最后一个非终结符符号的资格。我采用
两个变量来实现的。last_character_is_end和is_null来实现。last_character_is_end代表上一个文法符号（终
结符和非终结符）是否可以成为该表达式的最后一个非终结符。如果可以的话，并且is_null（又代表上一个文法符号
的first时候包含空串）==1（表达含有空串），那么curchar也就可以成为该表达式的最后一个非终结符。我一开始
还想的一个方法就是在Follow_set结构体中包含这样一个结构，但是一想，那样就比较浪费内存了。

b.这个方法在for循环的一开始就在寻找一个非终结符，如果，找找到的非终结符不是最后一个字符，说明，后面是
一个终结符，所以last_character_is_end=0;如果是一个非终结符，那么在for循环开始就是1了。

c.在使用这个方法的时候，特别要注意'|'的符号的处理，如果curchar后面是一个'|'，那么就不用看后面文法符号
是不是包含空串了。

d.在每扫描一个产生式的时候，都会要重置一下这两个参数，因为对于不同的产生式而言，这两个参数是没有意义的
所以，我就直接将其定义在了这个for循环的开始。last_character_is_end初始化为1，is_null初始化为0

8.在得到一个非终结符的函数get_variable(char *src,int *sindex)中,虽然参数使用的是char *.但是实
际上还是仅仅采用的是一个char ch[2].不然的话，在find_vt()函数中会出现问题。


9.copy_follow_first()函数设计初衷：
a.每次得到两个集合（是FiRST和FOLLOW的组合），需要复制同时判断是否含有空。

b.可能是FOLLOW相互复制，也有可能是FIRST复制给FOLLOW

c.在执行的函数的过程中就执行了非重复，非空串复制也有可能没有复制（因为都是一些重复的元素），所以
还要使用flag来判断。因为在最外层的while()中就是使用flag来判断FOLLOW集合是不是稳定了。所以，这里
传入一个flag，来做这个事情。

10.对于求FOLLOW集合的时候，我没有采用和FIRST集合时一样的方法，采用一个在Follow_set中的flag字段来判断
是不是新增加了元素。原因是因为Follow集合的产生，不仅仅要有FIRST集合的值，还有FOLLOW集合的值。就目前
来看，没有找到一个好的方法来判断。目前采用的就是都是直接复制，但是会判断是否有重符元素。



****代码问题
1.在get_first()中，你一开始写成了strncpy(tmp, (const char*)Pstring[i].data[j], n);
但是你要清楚就是：Pstring[i].data[j]是一个char，而不是一个char
*。所以你上面的strncpy()函数就会报错

2.在find_vt()中：
a.你尝试将‘@’和char*str来比较的时候，因为你在上面使用了‘@’的宏定义，所以
if (!strcmp(str, (const char*)EMPTYSTRING))也是会报错的。因为宏展开的时候仅仅是字符替代而已，
所以就是if(!strcmp(str,(constchar*)‘@’))这个也是错误的。我觉得就是因为‘@’是一个常量吧，、
但是这样子的话，前面加上一个取地址就没有问题了。但是还是有问题。所以，最后就使用一个变量ch来代替了。
b.在使用char ch='@'去比较的时候，不要仅仅使用一个char ch；因为strcmpy()函数是要根据'\0'来正确使用的
所以你要构建一个数组：char ch[2]={'@','\0'}来调用strcmp()函数

3.要注意自己的定义的数据结构；对于FIRST集合来说里面是一个DyString,但是对于Pstring之类的来说，是一个
char *。因为你将他们都写成了data，尤其在strncpy()中比较容易出错。

4.在代码中，我一直出现一个 Run-Time Check Failure #2 - Stack around the variable 'ch1' was corrupte
的问题。我上网查找问题之后，网友说可能是内存访问错误，也就是可能使用了负数当作下标去访问内存。我想
这个编译器应该会报别的错误啊！怎么可能会是这个错误。但是我也就死马当做活马医，发现果然不是这个问题。
但是，最后上网看到一篇文章，说一般这样问题就是malloc()等内存操作函数的问题。然后我刚刚细细检查，发现
就是在定义了char ch1[MAXCHARNUM];但是在get_complete_vt()函数中却是这样memset()的。
memset(dst, 0,	MAXVTPNUM);也就是说，我分配了MAXCHARNUM（宏定义为16）个内存，但是却初始化
MAXVTPNUM（宏定义为32）个内存。所以在函数结束的时候，就会出现这样的问题。这里说到是ch1错误，你就在
ch1的周围好好好检查就好了。

5.想find_first_index()这样的函数，参数是一个char*str。如果你想要传入的是一个charch；然后你尝试
使用&ch当作实参传入进去，这样也是不可以的。因为你得函数实现肯定是根据'\0'来做判断标记的。
你仅仅传入&ch，是没有'\0'标记的。

6.
