1.在三次握手阶段，我的一个问题就是在第三次握手的过程中，假如连接的发起方，没有携带
数据，那么请问服务器那端到底有没有会不会给出一个ACK。从书本P225页来看，是没有给出
一个ACK。如果第三次握手的时候，恰好这个数据包丢失了，那么这个和两次握手就没有什么
区别了。

2.还有一个问题就是，书本上说如果第三次握手没有携带数据的话，是不会消耗ACK的。那么
这不就是意味着即使这个数据包丢失了，也决对不会重传。因为接下来将会有一个正真的数据
包来作为数据传输。


这个判断程序，我是这样的一个想法。就是去实现书本上画的状态图。但是现在的问题就是：
我觉得实现那个状态图的话就是要使用很多的判断条件来做。我觉得这样子的程序难免就是
冗余的。还有，就是对于像“标识符”，“关键字”这样很像的话，我如果先笼统的判断的话，
那么我觉得对于一个数据就不好区分了。如果先很细致的判断，就会导致程序的效率不高。
我问没有查百度，因为这样子我就直接看到别人写的源代码了。所以就来问问你了。总结
起来就是这样的一个问题：“为了识别出来各个词素，我去实现书本上画的那种状态转化图
这个思路对不对？如果是这样的话，那么我觉得代码里面就是很多重判断，因此我觉得这样
的代码质量不高。”


后来你要我使用一个图来来实现，我一开始的想法就是使用一个大类来实现。也就是说，
他们分别代表字母，数字，运算符，下划线等。但是我发现这样的话就会导致出现顺序
问题。而普通的图是没有顺序问题的。因此，我这个想法应该有问题。

但是书本上的状态转化图就是代表的一种状态。也就是说，他本来就是会包含很多字符的。
所以上面的方法问题应该不大。但是还是没有找到一个合适的方法来处理“顺序”问题。

对于最后顺序问题我是这样理解的：我只要将图的值不要简简单单的设置为1就可以了。因
因为对于顺序问题，即使一步小心先使用了那个规则，但是使用用过一次下次就不可以使用
了。所以最后还是仅仅可以匹配一次就没有了。

但是使用这个方法的缺陷在于这里仅仅只能识别小写字符和*。明显实际生活中就不是这个样子。
所以现在的问题就是怎么解决这个问题。不过我现在先去测试以下如何将单词转化为一个正则
表达式。

现在我觉得的由浅入深应该是：
	1.单词与正则表达式的匹配 
	2.正则表达式转化为NFA
	3.NFA转化为中间状态DFA(可能没有化简)
	4.DFA化简
	5.单词变成正则表达式·
	
	
2.正则表达式转化为NFA
大概思路就是这个样子：首先对于能够创建一个状态的，就可以直接先创建一个状态
然后使用正则表达式中的运算符将其连接起来。所以，这里需要设置两个栈。一个是
运算符栈，还有一个就是NFA状态栈。然后每一次连接两个状态的时候，得首先将他们
填写到图中。因为最后，我们打算就是使用一个图来代表整个状态.其实这个也是很符
和实际的情况。因为我把书本上的DFA自动机可以转化为一个图。然后图我打算使用二维
数组来描述。所以每一个元素的值就是连接这个两个状态的字符（可能是字母表中的字符
也可能是空字符


从书本上的图就可以看出来，对于一个字母（非运算符），那么我们就得构造出两个对象出来。
在正则表达式中就只有'('	        ')'        '*'            '|'
四种运算符。我现在的主要任务就是区分它们，做出不同的判断。

然后发现了一个问题。实际上我们是不可以使用一个链表来实现这个状态图的。因为NFA难免会
存在这个有多条路径的问题，所以，唯一的解决方法就是直接构建出一个图出来。而不是根据
一个链表（我一开始以为可以构建出这样的状态图出来）。


我现在的想法就是：对于正则表达式的处理分为两个部分：第一就是“非运算符”，第二就是“运算符”
但是现在就是对于状态图中的每一个状态都可以设置为一个节点压入栈中，然后同时修改图中信息
如果遇到运算符（|，*，（，）），就得根据他们的性质来节点栈中的操作。通过观察发现，其实
节点栈中也仅仅只有不超过两个节点存在（目前我就只能这么认为了）。


后来我觉得在龙书中有两个点没有描述出来。也就是说，对于龙书上面的代码，是没有
实现的。第一：对于aabb这样的，代表的是a连接a连接b连接b,所以，为了达到在NFA栈
中，我们必须要在读入运算符后再去栈中取出两个NFA来操作。第二：就像使用四则运算
使用栈来实现的时候，一定都得转化为后缀表达式。
最后，我在一个博客中有人都提到了这点。
https://blog.csdn.net/johnf_nash/article/details/22086149
在手动测试的过程中，我还发现一个重要的问题，就是对于'*'运算符你可以理解为一个单目运算符
但是我为了不破坏代码的完整性，我就是在显式手动添加一个'+'时候，顺便还在'*'中也添加了这个
'+'。因为这个样子就可以保证我在转化为后缀表达的时候，就能够使用一套算法来实现了


其实在实现的时候，对于每一个字符采用的都是先创建一个NFA节点就好了。



=======2019.09.10.17:41(Tuesday)=======
总的来说，就是分类来讨论。注意：
对于'|'来说：是要创建两个状态出来，也就是要产生一个NFA节点
对于'*'来说：仅仅是要创建一个状态出来，但是也要产生一个NFA节点。所不同的在于他还要index--
对于'+'来说：不需要创建NFA节点。只要把NFA栈里面节点做一下调整就好了。



但是对于NFA的时候你会调整状态的编号，这样子有没有影响。因为你的closure计算出来的
是直接按照图的顺序计算的。感觉会有影响

=======2019.09.12.16:19(Thursday)=======
在我这两天编译原理和毛概的课堂上面的思考（这样子说实话不太好。逃。。。）下面是我总结出的规律：
1.'*'也要创建状态，但是仅仅只消耗一个index，尤其是tmp2作为一个'*'的操作对象。记住，这里说的tmp2
就是指从NFA栈中出来的第二个节点。第一个节点是tmp1。当然，每一个操作符对象每一次仅仅只会从NFA栈中
弹出两个对象来操作。
2.'+'不用创建状态，但是tmp1要接在tmp2之后。这点很重要。因为你就是因为这个原因才“看破”正则中缀
转化为正则后缀的“为什么一定要使用优先级了！”
3.'|'要创建两个状态，且消耗四个状态。目前看来这个是最简单的一种情况

关于正则中缀转化为正则后缀的时候到底是不是需要优先级来进出栈的问题：
1.其实这个问题使我纠结了很久。因为我一开始在实现龙书上算法3.23的时候，大部分代码都是直接按照书本上
画的图转化出来的，其实没有自己深入研究。但是，在实现中缀到后缀的转化的时候，就出现了一个问题。我发现
自己不得不去考虑这个问题了。
2.其实自己的第一直觉是要实现优先级的，因为这个就是数据结构中中缀表达式转化为后缀表达式的的思想。但是
我后来自己测试，发现又不能实现优先级。于是我就尝试不去实现优先级的方法，来实现后缀表达式的实现。最后，
发现还是不符合书本上画出的图。
3.最后，要问坚定的认为一定要分优先级的情况是因为：在遇到'+'运算符的时候，一定要使用tmp1接在tmp2的后面。
只有这样子，一切的说法才是合适的。
4.最后，我还用一些其他的说法证明了自己的观点：因为如果没有优先级的话，那么中缀转化为后缀表达式就是没有
任何意义的。那么仅仅就交换了字符和运算符之间的顺序。其二：如果没有优先级的话，那么你得()字符的强制入栈
又是怎么回事。

比较满意的就是这次的malloc()函数使用之后每一次都是回收了所有的内存的。也不能说所有吧，反正就是把我觉得
应该要回收的内存都回收了。这一点我觉得还是相比之前有很大的进步。因为在这种递归里面不断的使用malloc()函数
来分配内存，极容易造成内存空间的极大浪费。

自己注意，在编程的时候，最后中缀转化为后缀时候，记得字符串后面加上'\0'
在得到初始状态的函数中，一定使用dfs的方法来求出所有的可达的状态。不然你的状态就是会比别人少一些。
就是在这里会有一个很纠结的问题：如果使用dfs的方法，就每一次仅仅只能返回一个值，如果你要返回多个
状态的话，那么也还是要分配内存空间，但是我就是觉得这样子很不值得。每次都会浪费好多空间。
但是细细一想，好像可以使用free()来回收我的空间。嗯嗯，去尝试一下




=======2019.09.13.08:54(Friday)=======
1.刚刚在测试的时候，发现了一个重大的问题。就是我使用字符来表示状态，但是我前面都是使用的数字来代表状态的。
问题就在于对于数字字符来说只有'0'~'9',没有别的数字字符了。那么这样打印出来的状态就是不完整的了。会出现
一些别的字符。暂时还没有想到处理的方法。
暂时我的想法就是如果遇到状态10及其以后的状态，就直接转化为状态a及其以后。·

2.对于你自己的move()函数实现的使用，为了代码的简洁，所以直接将处理“空状态”和“接收字符ch状态”的处理放到
了一起。但是这样当初有一个问题我就没有考虑到：对于“空状态”来说的确需要递归的调用来得到所有的状态。但是
对于接收“字符ch状态”来说仅仅只要扫描自己本行就可以了。所以不要递归调用。

3.对于'+'的处理，因为这个建立的状态有所不同，所以我们一定要使用清楚原来的一个状态的方法，不让的话，就会
出现状态错误的问题。

4.每次对栈操作时候可以检查一下栈是否为空，这个是一个好习惯。尤其是当你的栈操作在一个循环里面的时候，特别
容易出现栈为空了你还在操作栈


=======2019.09.13.14:57(Friday)=======
1.关于正则表达式转化为DFA的正确理解，下面的这个博客讲的比较详细，而且还有为什么！！
https://www.cnblogs.com/dzodzo/archive/2009/12/15/1624225.html

2.下午就开始着手计算怎么直接将正则表达式转化为DFA状态图
第一步就是要得到一个抽线语法树。通过书本上的图，我的第一感觉就是有点像Huffman树。所以，其实我想打算使用
数组来存放的。但是后来看到书本P43的说法，感觉还是使用链表靠谱一点。因为你之后计算nullable之类的时候，还是
要使用这个抽线语法树来计算的。

3.看到书本上的抽象语法树的时候，有一点还是有点不能理解。就是书本P110，我上面写着的节点n，但是这个节点的
构造我还是不是特别清楚。所以我上网搜一下。网上没有找到合适的答案。但是我自己想出了一个方法来创建这样的
抽象语法树。但是有一个问题就是：这里为什么一定要构造这样的抽线语法树。按照我的逻辑，构造的语法树就不是
这个样子。区别在于'*'到底连接几个节点。其实从正则表达式上来看，'*'运算符应该仅仅只能连接一个节点，因为
'*'运算符是一个单目运算符，这个也是书本上构造出来的抽象语法树的样子。但是我的想法就是可以要'*'连接两个
节点，但是代码中要规定'*'仅仅作用于左子树，并且同时具备'+'的能力，要将左子树和右子树连接起来。其实这个
也是可以从表达式中可以看出来的。'*'是有这种连接的能力的。当然，可能我这样可能就会使'*'复杂一点。但是
其实这个问题我在NFA转化为DFA的时候也考虑过。算了，还是就按照书本上的抽象语法树来做吧。

4.如果实现书本上的抽线语法树，我的思路就是：
①：先显式的添加'+'运算符，不同于之前NFA到DFA的添加，这里对于'*'后面也要添加一个'+'
②：实现中缀正则到后缀正则的转化
③：对后缀正则表达式实现节点的构造，使用指针构造出一个抽线语法树

=======2019.09.13.18:07(Friday)=======
抽象语法树创建完毕






=======2019.09.14.14:24(Saturday)=======
今天上午学习Unix Network Promgramming，下午就来扛代码了，看看下午可不可把"直接转化为DFA实现"

1.看到书本上的例子，其实我一开始还在纠结怎么找一个地方来存放我计算的nullable,firstrpos,lastpos,followpos
但是其实是没有必要保存的。我们仅仅只要这四个函数就可以了。他们的结果都是算出来的了立即使用就好了。
但是为来节省效率，我觉得还是对followpos()函数的返回值进行保存比较好。先看看吧，马上写一个代码来验证一下。

2.发现如果真的不保存结果的话，效率可能就太低下了。虽然我现在写的程序是没有保存中间结果的代码，但是最后
我还是想要把代码优化一下。

3.突然想到一个点，就是我采用的是char*来存放每一个firstpos和lastpost集合的。所以，就会导致我的程序是
无法出现大于10以上的状态的。那么有一个扑救方法就是采用和之前NFA->DFA的方法，出现了10以上的状态，就
只能使用'a'~'z'来代替了。但是这个也是一个治标不治本的方法。因为这个表示也有可能被耗尽。但是仔细一想，
基本上不会有那么长的词素来识别吧！

4.对于followpos的计算。主要就是两个问题。第一：为什么仅仅只需要计算cat节点和start节点，这个你得清楚。
第二：对于start节点计算方法我一开始有点不理解，现在把我的理解记录下来。很明显，'*'节点肯定仅仅只有
一个孩子节点。这个孩子节点可以是单个叶子节点，也有可能是'|'运算符（就和书本上的例子一样），也有可能
是'+'（但是我还没有想出这样的正则表达式是怎么样的）。反正就是如果想要理解书本上的对于'*'节点公式，就
要记得一点，对于'*'而言，并不是每一次firstpos的结果和lastpost的结果都是计算的一样的。


=======2019.09.15.08:50(Sunday)=======
1.对于malloc()函数在释放的时候有一个很奇妙的地方。其实这个位置你之前的博客也写过。就是你如果仅仅只开了
sizeof(char)*5的内存，但是却使用了7个字节的内存。这个时候并不会报错。不管你是使用p[]这样的方式去使用，
还是使用strcpy()字符串操作函数去使用，都暂时不会报错。但是什么时候会出现问题呢？第一：在你free(p)的时候
就会出现问题。这个问题我记得侯捷老师讲过。第二：你得这个可能会影响到了你进程的别的位置的内存。这个问题
就比较隐蔽了，不太容易发现。我记录下来这个问题的原因就是因为我在free()的时候出现了问题！！！

2.在求followpos的时候，我一开始觉得我自己写的算法是不是有点问题。因为我觉得我好像没有考虑到重复的问题。
至于我为什么会这样想，就是因为在龙书113页中就是出现了一个重复的状态。但是我仔细一想，是不会出现重复的
状态的。虽然我的状态最后都是strcat()上去的，但是对于每一个cat节点和start节点来说，其实都是会有一新的
节点出现。所以，每一次都是会有新的strcat()上去。所以，目前看来我的代码应该是没有问题的。

3.关于strcpy()函数到底会不会将src的'\0'也复制给des的问题，暂时还不清楚。这个我觉得要看源代码的实现。
但是我在我的代码中就是多分配一个内存，自己来存。这样子比较保险

=======2019.09.15.11:14(Sunday)=======
正则表达式->DFA success!!!
我的直觉告诉我，我的程序对于左右子树的依赖存在，所以程序中肯定还有bug，下午记得测:
关于'*'为什么要每一个follow[lastpos(n)]=firstpos(n);如果‘*’仅仅做一次运算的确没有什么特殊。但是如果，'*'
做了多次运算，那么这个表示的意思就是自己到自己的转圈圈了。所以这样子的表示是合理的





=======2019.09.15.14:36(Sunday)=======
下午开始总结一下自己的代码上的一些问题，算是一个文档吧。毕竟这个笔记仅仅是记录给我自己看的。
修改的地方：
1.在infixTopostfix()函数中，len的长度+1。这样子的确就可以消除那样的问题了。那么我同时还发现的一个问题
就是，如果你要看你的字符串在你分配的长度之内最后有没有字符'\0'，在调试的时候鼠标放在上面，如果最后面
出现了一些乱码，就是没有'\0',如果恰好是你得字符长度，那么就是有'\0'

2.在构造抽象语法树的时候，栈中先出栈的成为右孩子。这个是书本上的规律我的出来的结论。但是如果将先出栈的
节点设置为左孩子，我觉得会影响到followpos()函数的计算。而且也不能修改。因为先出栈的就是后面加入的，所
以在正则表达式中就是在后面一点，那么按照逻辑来说就是右孩子

3.在求lastpost()的时候，我在递归调用的时候，竟然还是调用的是firstpos()函数。这里就是我复制的问题了。然后
还要注意的是，对于cat节点，相对于firstpos()的c1和c2的规则要互换，也就是左右孩子的互换。

4.在followpos()函数的计算过程中，我一开始以为右孩子肯定就是一个完全的叶子节点（就和书本上画的一样），但是
实际上不是这样的。你的第二个测试数据就出现了右孩子可能还包含一个'*'运算符。所以，你之前的followpos()的
代码就要修改一下，增加右孩子的计算。

5.在direct_converion_dfa()函数中，有一个判断状态p中是否有对应的位置的时候，可能一个位置都没有找到。就像
你的第二个测试用例，开始的状态只有1，在图中状态1对应的是输入字符a,所以对于其他的输入字符来说，是没有对
应的状态生成的。但是你的代码却没有考虑到这样的情况，导致最后认为u->str为""也认为是一个新的状态。所以，
修改一下find_state()函数，如果strlen(u->str)=0,那么也认为状态存在。

6.我的代码没有考虑输入的字符会有空串的情况。对于这样的情况，nullable()一系列的函数都要做出相应的修改。

7.测试用例3給我的问题就是，在这个正则表达式中，根本就不需要将'*'运算符后面显式的添加一个'+'。但是测试
用例1给我的想法就是'*'后面要手动添加一个'+'。那么，这两个问题就是矛盾的。那么我总结出来的一个结论就是：
如果'*'运算符后面跟着的是一个运算符，那么就不用添加一个'+';如果'*'运算符后面跟着的是一个字符，那么就要
手动添加一个'+'。这个是暂时的解决方法吧，我只能这么说了。

8.在求followpos()函数之中，我每次都会去判断现在的follow[n]数组现在是否有元素了。但是就和测试用用例3一样，
可能在follow[n]已经有元素存在一部分了。所以后面你在添加的时候不能蛮目的直接添加进去，而是要首先判断你要
添加的状态现在是不是已经存在了。所以，在followpos()函数之中，还要检查这个状态在follow[n]里面是不是已经
存在了。

代码中不确定的地方：

















===============================Code============================================
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

int main()
{
	char *s=(char*)malloc(sizeof(char)*10); 
	memset(s,0,sizeof(char)*10);
	s[0]='1';
	s[1]='2';
	for(int i=0;i<10;i++)
	{
		printf("%d\t",s[i]);
	}
	printf("%d-------%d",sizeof(s),strlen(s)); 
	return 0;
 } 
//上面的代码给我的启示就是：
1.strlen()函数是可以直接计算字符长长度的，但是计算的原理是“找到第一个不为\0的字符”
2.因为malloc分配的内存没有初始化，所以导致里面的内容可以是随机的。所以，你在赋值
几个字符之前，首先使用memset()函数初始化一下比较好。这个也是你今后编程的一个习惯
使用malloc()之后，一定要memset()一哈。尤其是你的数据将来是用来存放字符串
3.还有一个问题：至于scanf("%s",s);如果s没有memset的话，scanf()到底会不会帮忙初始化
s这个我测试了，但是得到是一个不确定答案。所以，最好是自己手动初始化，作为一个良好
的程序员，不能去依赖“你觉得他会这样做的思想”，而是自己手动操作
4.关于strcat()函数的运行原理，我也测试了一下。就是找到des字符串中的第一个'\0'开始拼接，
所以，这里又可以说明一定要使用memset()来初始化分配的内存。尤其是你如果要使用其作为一个
字符串的时候



------代码问题：
关于全局变量的误区。我以为全局变量就是在一个函数就可以全部直接影响。但是实际的情况不是这样的；
#include<stdio.h>

int index=0;

void fun(int i)
{
	i++;
}

int main()
{
	for(int i=0;i<10;i++)
	{
		fun(index);
		printf("%d",index);
	}
	return 0;
 } 

------

int main()
{
	char *str1=(char*)malloc(sizeof(char)*10);
	memset(str1,0,sizeof(char)*10);
	char ch='2'; 
	scanf("%s",str1); 
	strcat(str1,&ch);
	for(int i=0;i<10;i++)
	{
		printf("%s\t",str1);
	}
	return 0;
 }

这个代码告诉我不能将一个字符直接strcat()到这个后面，会出现大问题
