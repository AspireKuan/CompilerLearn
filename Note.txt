1.在三次握手阶段，我的一个问题就是在第三次握手的过程中，假如连接的发起方，没有携带
数据，那么请问服务器那端到底有没有会不会给出一个ACK。从书本P225页来看，是没有给出
一个ACK。如果第三次握手的时候，恰好这个数据包丢失了，那么这个和两次握手就没有什么
区别了。

2.还有一个问题就是，书本上说如果第三次握手没有携带数据的话，是不会消耗ACK的。那么
这不就是意味着即使这个数据包丢失了，也决对不会重传。因为接下来将会有一个正真的数据
包来作为数据传输。


这个判断程序，我是这样的一个想法。就是去实现书本上画的状态图。但是现在的问题就是：
我觉得实现那个状态图的话就是要使用很多的判断条件来做。我觉得这样子的程序难免就是
冗余的。还有，就是对于像“标识符”，“关键字”这样很像的话，我如果先笼统的判断的话，
那么我觉得对于一个数据就不好区分了。如果先很细致的判断，就会导致程序的效率不高。
我问没有查百度，因为这样子我就直接看到别人写的源代码了。所以就来问问你了。总结
起来就是这样的一个问题：“为了识别出来各个词素，我去实现书本上画的那种状态转化图
这个思路对不对？如果是这样的话，那么我觉得代码里面就是很多重判断，因此我觉得这样
的代码质量不高。”


后来你要我使用一个图来来实现，我一开始的想法就是使用一个大类来实现。也就是说，
他们分别代表字母，数字，运算符，下划线等。但是我发现这样的话就会导致出现顺序
问题。而普通的图是没有顺序问题的。因此，我这个想法应该有问题。

但是书本上的状态转化图就是代表的一种状态。也就是说，他本来就是会包含很多字符的。
所以上面的方法问题应该不大。但是还是没有找到一个合适的方法来处理“顺序”问题。

对于最后顺序问题我是这样理解的：我只要将图的值不要简简单单的设置为1就可以了。因
因为对于顺序问题，即使一步小心先使用了那个规则，但是使用用过一次下次就不可以使用
了。所以最后还是仅仅可以匹配一次就没有了。

但是使用这个方法的缺陷在于这里仅仅只能识别小写字符和*。明显实际生活中就不是这个样子。
所以现在的问题就是怎么解决这个问题。不过我现在先去测试以下如何将单词转化为一个正则
表达式。

现在我觉得的由浅入深应该是：
	1.单词与正则表达式的匹配 
	2.正则表达式转化为NFA
	3.NFA转化为中间状态DFA(可能没有化简)
	4.DFA化简
	5.单词变成正则表达式·
	
	
2.正则表达式转化为NFA
大概思路就是这个样子：首先对于能够创建一个状态的，就可以直接先创建一个状态
然后使用正则表达式中的运算符将其连接起来。所以，这里需要设置两个栈。一个是
运算符栈，还有一个就是NFA状态栈。然后每一次连接两个状态的时候，得首先将他们
填写到图中。因为最后，我们打算就是使用一个图来代表整个状态.其实这个也是很符
和实际的情况。因为我把书本上的DFA自动机可以转化为一个图。然后图我打算使用二维
数组来描述。所以每一个元素的值就是连接这个两个状态的字符（可能是字母表中的字符
也可能是空字符


从书本上的图就可以看出来，对于一个字母（非运算符），那么我们就得构造出两个对象出来。
在正则表达式中就只有'('	        ')'        '*'            '|'
四种运算符。我现在的主要任务就是区分它们，做出不同的判断。

然后发现了一个问题。实际上我们是不可以使用一个链表来实现这个状态图的。因为NFA难免会
存在这个有多条路径的问题，所以，唯一的解决方法就是直接构建出一个图出来。而不是根据
一个链表（我一开始以为可以构建出这样的状态图出来）。


我现在的想法就是：对于正则表达式的处理分为两个部分：第一就是“非运算符”，第二就是“运算符”
但是现在就是对于状态图中的每一个状态都可以设置为一个节点压入栈中，然后同时修改图中信息
如果遇到运算符（|，*，（，）），就得根据他们的性质来节点栈中的操作。通过观察发现，其实
节点栈中也仅仅只有不超过两个节点存在（目前我就只能这么认为了）。


后来我觉得在龙书中有两个点没有描述出来。也就是说，对于龙书上面的代码，是没有
实现的。第一：对于aabb这样的，代表的是a连接a连接b连接b,所以，为了达到在NFA栈
中，我们必须要在读入运算符后再去栈中取出两个NFA来操作。第二：就像使用四则运算
使用栈来实现的时候，一定都得转化为后缀表达式。
最后，我在一个博客中有人都提到了这点。
https://blog.csdn.net/johnf_nash/article/details/22086149
在手动测试的过程中，我还发现一个重要的问题，就是对于'*'运算符你可以理解为一个单目运算符
但是我为了不破坏代码的完整性，我就是在显式手动添加一个'+'时候，顺便还在'*'中也添加了这个
'+'。因为这个样子就可以保证我在转化为后缀表达的时候，就能够使用一套算法来实现了


其实在实现的时候，对于每一个字符采用的都是先创建一个NFA节点就好了。



------代码问题：
关于全局变量的误区。我以为全局变量就是在一个函数就可以全部直接影响。但是实际的情况不是这样的；
#include<stdio.h>

int index=0;

void fun(int i)
{
	i++;
}

int main()
{
	for(int i=0;i<10;i++)
	{
		fun(index);
		printf("%d",index);
	}
	return 0;
 } 
=======2019.09.10.17:41(Tuesday)=======
总的来说，就是分类来讨论。注意：
对于'|'来说：是要创建两个状态出来，也就是要产生一个NFA节点
对于'*'来说：仅仅是要创建一个状态出来，但是也要产生一个NFA节点。所不同的在于他还要index--
对于'+'来说：不需要创建NFA节点。只要把NFA栈里面节点做一下调整就好了。



但是对于NFA的时候你会调整状态的编号，这样子有没有影响。因为你的closure计算出来的
是直接按照图的顺序计算的。感觉会有影响

=======2019.09.12.16:19(Thursday)=======
在我这两天编译原理和毛概的课堂上面的思考（这样子说实话不太好。逃。。。）下面是我总结出的规律：
1.'*'也要创建状态，但是仅仅只消耗一个index，尤其是tmp2作为一个'*'的操作对象。记住，这里说的tmp2
就是指从NFA栈中出来的第二个节点。第一个节点是tmp1。当然，每一个操作符对象每一次仅仅只会从NFA栈中
弹出两个对象来操作。
2.'+'不用创建状态，但是tmp1要接在tmp2之后。这点很重要。因为你就是因为这个原因才“看破”正则中缀
转化为正则后缀的“为什么一定要使用优先级了！”
3.'|'要创建两个状态，且消耗四个状态。目前看来这个是最简单的一种情况

关于正则中缀转化为正则后缀的时候到底是不是需要优先级来进出栈的问题：
1.其实这个问题使我纠结了很久。因为我一开始在实现龙书上算法3.23的时候，大部分代码都是直接按照书本上
画的图转化出来的，其实没有自己深入研究。但是，在实现中缀到后缀的转化的时候，就出现了一个问题。我发现
自己不得不去考虑这个问题了。
2.其实自己的第一直觉是要实现优先级的，因为这个就是数据结构中中缀表达式转化为后缀表达式的的思想。但是
我后来自己测试，发现又不能实现优先级。于是我就尝试不去实现优先级的方法，来实现后缀表达式的实现。最后，
发现还是不符合书本上画出的图。
3.最后，要问坚定的认为一定要分优先级的情况是因为：在遇到'+'运算符的时候，一定要使用tmp1接在tmp2的后面。
只有这样子，一切的说法才是合适的。
4.最后，我还用一些其他的说法证明了自己的观点：因为如果没有优先级的话，那么中缀转化为后缀表达式就是没有
任何意义的。那么仅仅就交换了字符和运算符之间的顺序。其二：如果没有优先级的话，那么你得()字符的强制入栈
又是怎么回事。

比较满意的就是这次的malloc()函数使用之后每一次都是回收了所有的内存的。也不能说所有吧，反正就是把我觉得
应该要回收的内存都回收了。这一点我觉得还是相比之前有很大的进步。因为在这种递归里面不断的使用malloc()函数
来分配内存，极容易造成内存空间的极大浪费。

自己注意，在编程的时候，最后中缀转化为后缀时候，记得字符串后面加上'\0'
在得到初始状态的函数中，一定使用dfs的方法来求出所有的可达的状态。不然你的状态就是会比别人少一些。
就是在这里会有一个很纠结的问题：如果使用dfs的方法，就每一次仅仅只能返回一个值，如果你要返回多个
状态的话，那么也还是要分配内存空间，但是我就是觉得这样子很不值得。每次都会浪费好多空间。
但是细细一想，好像可以使用free()来回收我的空间。嗯嗯，去尝试一下




=======2019.09.13.08:54(Friday)=======
1.刚刚在测试的时候，发现了一个重大的问题。就是我使用字符来表示状态，但是我前面都是使用的数字来代表状态的。
问题就在于对于数字字符来说只有'0'~'9',没有别的数字字符了。那么这样打印出来的状态就是不完整的了。会出现
一些别的字符。暂时还没有想到处理的方法。
暂时我的想法就是如果遇到状态10及其以后的状态，就直接转化为状态a及其以后。·

2.对于你自己的move()函数实现的使用，为了代码的简洁，所以直接将处理“空状态”和“接收字符ch状态”的处理放到
了一起。但是这样当初有一个问题我就没有考虑到：对于“空状态”来说的确需要递归的调用来得到所有的状态。但是
对于接收“字符ch状态”来说仅仅只要扫描自己本行就可以了。所以不要递归调用。

3.对于'+'的处理，因为这个建立的状态有所不同，所以我们一定要使用清楚原来的一个状态的方法，不让的话，就会
出现状态错误的问题。

4.每次对栈操作时候可以检查一下栈是否为空，这个是一个好习惯。尤其是当你的栈操作在一个循环里面的时候，特别
容易出现栈为空了你还在操作栈


=======2019.09.13.14:57(Friday)=======
1.关于正则表达式转化为DFA的正确理解，下面的这个博客讲的比较详细，而且还有为什么！！
https://www.cnblogs.com/dzodzo/archive/2009/12/15/1624225.html

2.下午就开始着手计算怎么直接将正则表达式转化为DFA状态图
第一步就是要得到一个抽线语法树。通过书本上的图，我的第一感觉就是有点像Huffman树。所以，其实我想打算使用
数组来存放的。但是后来看到书本P43的说法，感觉还是使用链表靠谱一点。因为你之后计算nullable之类的时候，还是
要使用这个抽线语法树来计算的。

3.看到书本上的抽象语法树的时候，有一点还是有点不能理解。就是书本P110，我上面写着的节点n，但是这个节点的
构造我还是不是特别清楚。所以我上网搜一下。网上没有找到合适的答案。但是我自己想出了一个方法来创建这样的
抽象语法树。但是有一个问题就是：这里为什么一定要构造这样的抽线语法树。按照我的逻辑，构造的语法树就不是
这个样子。区别在于'*'到底连接几个节点。其实从正则表达式上来看，'*'运算符应该仅仅只能连接一个节点，因为
'*'运算符是一个单目运算符，这个也是书本上构造出来的抽象语法树的样子。但是我的想法就是可以要'*'连接两个
节点，但是代码中要规定'*'仅仅作用于左子树，并且同时具备'+'的能力，要将左子树和右子树连接起来。其实这个
也是可以从表达式中可以看出来的。'*'是有这种连接的能力的。当然，可能我这样可能就会使'*'复杂一点。但是
其实这个问题我在NFA转化为DFA的时候也考虑过。算了，还是就按照书本上的抽象语法树来做吧。

4.如果实现书本上的抽线语法树，我的思路就是：
①：先显式的添加'+'运算符，不同于之前NFA到DFA的添加，这里对于'*'后面也要添加一个'+'
②：实现中缀正则到后缀正则的转化
③：对后缀正则表达式实现节点的构造，使用指针构造出一个抽线语法树

=======2019.09.13.18:07(Friday)=======
抽象语法树创建完毕
===============================Code============================================
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

int main()
{
	char *s=(char*)malloc(sizeof(char)*10); 
	memset(s,0,sizeof(char)*10);
	s[0]='1';
	s[1]='2';
	for(int i=0;i<10;i++)
	{
		printf("%d\t",s[i]);
	}
	printf("%d-------%d",sizeof(s),strlen(s)); 
	return 0;
 } 
//上面的代码给我的启示就是：
1.strlen()函数是可以直接计算字符长长度的，但是计算的原理是“找到第一个不为\0的字符”
2.因为malloc分配的内存没有初始化，所以导致里面的内容可以是随机的。所以，你在赋值
几个字符之前，首先使用memset()函数初始化一下比较好。这个也是你今后编程的一个习惯
使用malloc()之后，一定要memset()一哈。尤其是你的数据将来是用来存放字符串
3.还有一个问题：至于scanf("%s",s);如果s没有memset的话，scanf()到底会不会帮忙初始化
s这个我测试了，但是得到是一个不确定答案。所以，最好是自己手动初始化，作为一个良好
的程序员，不能去依赖“你觉得他会这样做的思想”，而是自己手动操作
4.关于strcat()函数的运行原理，我也测试了一下。就是找到des字符串中的第一个'\0'开始拼接，
所以，这里又可以说明一定要使用memset()来初始化分配的内存。尤其是你如果要使用其作为一个
字符串的时候
